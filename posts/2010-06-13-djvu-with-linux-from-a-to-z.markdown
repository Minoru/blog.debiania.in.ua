---
title: Создание Djvu документов в Linux от А до Я
published: 2010-06-13T22:36:00Z
categories: 
tags: tips'n'tricks
---

Если с PDF всё ясно и понятно, то сборка djvu–документов часто является неким сокровенным знанием. <a href="http://www.howtoforge.com/creating_djvu_documents_on_linux">Наиболее полный мануал</a> почему–то обходит стороной такие (довольно важные) моменты, как кодирование цветных изображений и распознавание текста, так что я решил восполнить сей пробел и написать этот пост (позже было добавлено ещё несколько разделов — смотрите раздел <a href="#updates">UPD</a>). Большая его часть будет пересказом упомянутого руководства; дополнениями станут рассказ о кодировании полноцветных изображений и пояснения к созданию текстового слоя. Для удобства я разбил пост на отдельные части:<ol><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#intro">Вводные замечания</a></li><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#compressing_whitenblack_images">Кодирование чёрно–белых изображений</a></li><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#compressing_grayscale_images">Кодирование оттенков серого</a></li><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#compressing_fullcolor_images">Кодирование цветных изображений</a></li><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#ocr">Распознавание текста (OCR) и создание текстового слоя</a></li><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#links_in_table_of_contents">Ссылки в оглавлении</a></li><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#metainformation">Метаинформация</a></li><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#dealing_with_non-ascii_symbols">Работа с не–ASCII символами</a></li><li><a href="http://debiania.blogspot.com/2010/06/djvu-linux.html#creating_djvu_file">Сборка итогового djvu–документа</a></li></ol><a name='more'></a><a name="intro"></a><h3>Вводные замечания</h3>Итак, последовательность создания djvu–документа примерно такова:<ol><li>Сканирование книги и чистка сканов (по возможности, фон должен быть белым, а текст — чёрным) <i>(этот пункт в данной статье не рассматривается — предполагается, что сканы у вас уже есть; если это не так, сканируйте, обрабатывайте результат — кстати, комментаторы настоятельно рекомендуют использовать Scan Tailor — и возвращайтесь к этой статье);</i></li><li>сжатие каждой страницы <u>отдельно</u> в зависимости от её содержания (не бойтесь слова «отдельно» — операции легко автоматизируются и, скорее всего, вам подойдёт сжатие всех страниц в оттенках серого);</li><li>опционально — добавление текстового слоя;</li><li>сборка из полученных отельных djvu–файлов одного, финального.</li></ol>Теперь касательно используемых программ: фактически нам нужны только утилиты, входящие в пакеты <code>djvulibre-bin</code>, <code>netpbm</code> и <code>imagemagick</code>. Всё это добро легко ставится из репозиториев:<div class="code"><code>$ sudo aptitude install djvulibre-bin netpbm imagemagick</code></div>Ну что же, план действий у нас есть, снаряжение подготовлено — в путь, друзья!<br /><br /><a name="compressing_whitenblack_images"></a><h3>Кодирование чёрно–белых изображений</h3>Сжимать сканы в чёрно–белом режиме имеет смысл только в том случае, когда полиграфия действительно качественная, а сканы практически идеальны — в противном случае вы рискуете получить некачественное изображение и/или много шума. Итак, для сжатия изображения в чёрно–белом режиме исходник надо перевести в формат pbm. Сделать это можно, используя утилиты из пакета <code>netpbm</code>:<div class="code"><code>$ anytopnm ИМЯ_ИСХОДНОГО_ФАЙЛА | ppmtopgm | pgmtopbm -value 0.499 &gt; ВЫХОДНОЙ_ФАЙЛ.pbm</code></div>Если вы именовали сканы последовательными номерами, можно использовать цикл. Так, следующая конструкция сконвертирует все tiff–файлы в pbm, меняя расширение:<div class="code"><code>for file in *.tiff; do anytopnm $file | ppmtopgm | pgmtopbm -value 0.499 &gt; ${file%tiff}pbm; done</code></div>Коэффициент 0.499 взят из уже упоминавшегося англоязычного руководства, в котором данная настройка называется оптимальной для большинства случаев. Правда, экспериментировать вам никто не запрещает :)<br />Наконец, преобразование pbm в djvu–файл выполняется командой:<div class="code"><code>$ cjb2 -dpi DPI ВХОДНОЙ_ФАЙЛ.pbm ИТОГОВЫЙ_ДОКУМЕНТ.djvu</code></div>Обратите внимание на опцию <code>-dpi</code> — вы должны самостоятельно задать «плотность» получающегося документа.<br />После конвертирования в djvu pbm–файлы могут быть удалены.<br />Помимо <code>cjb2</code>, существуют и другие инструменты для компрессии чёрно–белых изображений. В частности, monday2000 в комментариях советует использовать <code>minidjvu</code> (в Debian есть существующий пакет), а лучше — DjVu Solo 3.1, запущенный под Wine.<br /><br /><a name="compressing_grayscale_images"></a><h3>Кодирование оттенков серого</h3>Скорее всего, сканы окажутся не идеальными, а типография оставит желать лучшего, так что кодирование изображений в оттенках серого — это то, чем вы будете заниматься основную часть времени.<br />Для сжатия сканы придётся сконвертировать либо в JPEG (чего я <b>НЕ</b> рекомендую), либо в PPM/PGM. Поступим разумно и пойдём по второму пути:<div class="code"><code>$ anytopnm ИМЯ_ИСХОДНОГО_ФАЙЛА | ppmtopgm &gt; ВЫХОДНОЙ_ФАЙЛ.pgm</code></div>(думаю, для вас не составит труда самостоятельно написать цикл, автоматизирующий конвертирование всего набора сканов). Дальше в ход пойдёт утилита <code>cpaldjvu</code>:<div class="code"><code>$ cpaldjvu -dpi DPI -colors КОЛИЧЕСТВО_ОТТЕНКОВ_СЕРОГО ВХОДНОЙ_ФАЙЛ.pgm ВЫХОДНОЙ_ФАЙЛ.djvu</code></div>Как видите, добавляется новая интересная деталь — количество используемых оттенков серого. Чем больше это значение, тем больший объём имеет сжатая страница. Для не очень качественных сканов подойдёт значение 3 или 4 — этого вполне достаточно, чтобы получить пусть и бледноватую, но читабельную картинку.<br /><br /><a name="compressing_fullcolor_images"></a><h3>Кодирование цветных изображений</h3>Теперь самое интересное — кодирование цветных страниц. Как правило, в цвете кодируются только обложки, но вы вольны поступать так, как сочтёте нужным.<br />Сначала конвертируем обложку в PPM:<div class="code"><code>$ convert ИСХОДНЫЙ_СКАН РЕЗУЛЬТИРУЮЩИЙ_ФАЙЛ.ppm</code></div>Теперь сожмём её в Djvu:<div class="code"><code>$ c44 -dpi DPI ИСХОДНИК.ppm РЕЗУЛЬТАТ.djvu</code></div>Не забудьте заменить DPI на подходящее значение — всё остальное программа сделает сама.<br /><br /><a name="ocr"></a><h3>Распознавание текста (OCR) и создание текстового слоя</h3>Это опциональный пункт, можете пропустить его, если вам не нужен текстовый слой или вы попросту не хотите тратить время — операция распознавания довольно длительна, а вычитка получившегося текста — это вообще чуть ли не каторжный труд. «Думайте сами, решайте сами, иметь или не иметь…»<br />В принципе, распознавать имеет смысл только техническую литературу — к примеру, программисты гораздо больше обрадуются книге, из которой можно скопировать листинги. Художественную же литературу распознавать, как мне кажется, особого смысла нет — вспомните, когда у вас последний раз появлялось желание что–то скопировать из художественной книги? То–то же.<br />От слов перейдём к делу — поставим OCR–движок:<div class="code"><code>$ sudo aptitude install ocrodjvu</code></div><code>ocrodjvu</code> занимается распознанием текста непосредственно из djvu–файла. Он может как дописывать текстовый слой в обрабатываемый документ, так и создавать новый. Работает это чудо вот так:<div class="code"><code>$ ocrodjvu -o ВЫХОДНОЙ_ФАЙЛ.djvu ВХОДНОЙ_ФАЙЛ.djvu</code></div>или, если вы уверены, что хотите переписать оригинальный документ:<div class="code"><code>$ ocrodjvu --in-place ВХОДНОЙ_ФАЙЛ.djvu</code></div>Замечу, что <code>ocrodjvu</code> является фронт–ендом для различных OCR–движков (по умолчанию используется оболочка для Tesseract под названием OCRopus). Движки эти, к сожалению, поддерживают не так уж много языков. Русский распознаётся только с помощью Cuneiform (который сейчас в non–free ветке sid'а) и уже упоминавшимся tesseract. C’est la vie…<br />Ещё одним важным замечанием о распознавании является время его выполнения — вы можете распознавать документы и до, и после сборки их в единый файл. Правда, во втором случае вы наверняка потратите лишнее время на то, чтобы в цикле извлечь текст каждой страницы в отдельный файл, а потом так же запихнуть всё обратно. Тут уж поступайте, как знаете.<br />И последняя, но, вероятно, самая важная заметка — на счёт редактирования текстового слоя. Тут у вас два варианта: либо воспользоваться довольно удобной программкой под названием <code>djvusmooth</code> (спасибо за наводку, Lazy_Kent!), либо с помощью <code>djvused</code> извлекать текстовый слой и править его. Т.к. использование GUI не должно составить особого труда, на <code>djvusmooth</code> я останавливаться не буду — гораздо интереснее поковыряться во внутренностях Djvu и выяснить, как «руками» сделать всё то, что помогает делать графический интерфейс.<br />Начнём с базовых операций; вынуть текстовый слой всего документа можно так:<div class="code"><code>$ djvused ВХОДНОЙ_ФАЙЛ.djvu -e "print-txt" &gt; ВЫХОДНОЙ_ФАЙЛ.txt</code></div>После этого txt'шник можно открыть любимым vim'ом и править, править, править… О формате поговорим чуть позже. Когда закончите редактирование, вернуть текстовый слой на место помогут такие команды:<div class="code"><code>$ djvused ВХОДНОЙ_ФАЙЛ.djvu -s -e "remove-txt"<br />$ djvused ВХОДНОЙ_ФАЙЛ.djvu -s -e "set-txt ТЕКСТОВЫЙ_СЛОЙ.txt"</code></div>Первая команда удаляет уже существующий текстовый слой, вторая добавляет тот, что сохранён у нас в текстовом документе и который мы исправили.<br />Теперь касательно синтаксиса, используемого для описания текстового слоя. Тут всё базируется на списках, которые заключаются в круглые скобки и могут быть вложены друг в друга. Каждый список имеет следующую структуру:<div class="code"><code>(type xmin ymin xmax ymax ... )</code></div>На месте <code>type</code> должен быть один из следующих идентификаторов: <code>page</code> (страница), <code>column</code> (колонка), <code>region</code> (область), <code>para</code> (параграф), <code>line</code> (строка), <code>word</code> (слово) или <code>char</code> (символ). Дальше задаются координаты углов (левого верхнего и правого нижнего) прямоугольника, в котором лежит данный структурный элемент (страница, параграф, строка и т.д.).<br />Как уже было сказано, каждый список может содержать в себе другие списки. Поэтому логично организовать структуру текстового слоя примерно так:<pre class="code"><code>(page x1 y1 x2 y2<br />  (column x1 y1 x2 y2<br />    (region x1 y1 x2 y2<br />      (para x1 y1 x2 y2<br />        (line x1 y1 x2 y2<br />          (word x1 y1 x2 y2 "This")<br />          (word x1 y1 x2 y2 "is")<br />          (word x1 y1 x2 y2 "an")<br />          (word x1 y1 x2 y2 "example")<br />          (word x1 y1 x2 y2 "of")<br />          (word x1 y1 x2 y2 "possible")<br />          (word x1 y1 x2 y2 "hidden")<br />          (word x1 y1 x2 y2 "text")<br />          (word x1 y1 x2 y2 "description")<br />          (char x1 y1 x2 y2 ".")<br />        )<br />        (line x1 y1 x2 y2<br />          (word x1 y1 x2 y2 "Here")<br />          (word x1 y1 x2 y2 "goes")<br />          (word x1 y1 x2 y2 "second")<br />          (word x1 y1 x2 y2 "line")<br />          (char x1 y1 x2 y2 ".")<br />          (word x1 y1 x2 y2 "You")<br />          (word x1 y1 x2 y2 "have")<br />          (word x1 y1 x2 y2 "got")<br />          (word x1 y1 x2 y2 "that")<br />          (word x1 y1 x2 y2 "already")<br />          (char x1 y1 x2 y2 ",")<br />          (word x1 y1 x2 y2 "right")<br />          (char x1 y1 x2 y2 "?")<br />        )<br />      )<br />    )<br />  )<br />)</code></pre>Как видим, тут описан один параграф, состоящий из двух строк. Править это счастье не так уж сложно, если только распознавалка не склеила несколько слов вместе или не проигнорировала какую–то строку или символ. Для упрощения работы очень советую экспортировать обрабатываемую страницу в RAW PPM (вы можете использовать утилиту <code>ddjvu</code> или воспользоваться соответствующей возможностью стандартного просмотрщика <code>djview</code>), открыть её, скажем, в Gimp'е и там с помощью любого инструмента определять границы слова — текущее положение курсора отображается в левом нижнем углу окна с изображением (по крайней мере, так себя ведёт Gimp 2.6.8). Отсчёт почему–то начинается с <b>левого нижнего</b> угла, так что будьте внимательны.<br />Отдельно следует поговорить о не–ASCII символах — все они должны быть представлены в виде «UTF–8 encoded sequence», т.е. чего–то вроде такого: «\320\222\320\262\320\265\320\264\320\265\320\275\320\270\320\265». Т.к. об этом не расскажешь в паре абзацев, я написал об этом <a href="#dealing_with_non-ascii_symbols">отдельный раздельчик</a> — если будете править текстовый слой или метаинформацию (см. ниже), обязательно прочтите его.<br />Впрочем, можно обойтись и без этих премудростей с кодированием — у <code>djvused</code> есть опция <code>-u</code>, заставляющая его не перекодировать не–ASCII символы, а выводить их как есть, в UTF–8.<br />На этом, я думаю, повесть о текстовом слое можно завершить — вы уже знаете достаточно, чтобы создать, вычитать и встроить в документ качественную текстовую «подкладку».<br /><br /><a name="links_in_table_of_contents"></a><h3>Ссылки в оглавлении</h3>Согласитесь, пользоваться djvu–книгой станет гораздо удобнее, если пункты оглавления будут не просто текстом, а ссылками на соответствующие страницы. Djvu позволяет реализовать это счастье, используя механизм так называемых аннотаций (annotations). Как и текстовый слой, аннотации описываются с помощью списков, заключённых в круглые скобки.<br />Ссылки создаются с помощью структуры <code>maparea</code>, имеющей следующий формат:<div class="code"><code>(maparea url comment area ...)</code></div>Рассмотрим аргументы этой структуры по порядку.<br />Итак, <code>url</code>. Вообще–то тут можно указать ссылку на любой документ, а не только на страницу текущего файла — если вам это интересно, читайте <code>man 1 djvused</code>. Я же в дальнейшем буду говорить только о ссылках на страницы текущего документа. Они имеют очень простой формат: <code>#номер_страницы</code>, например, <code>#9</code>. Также допускаются относительные ссылки, имеющие знак — так, <code>#+1</code> отправит читателя на следующую страницу, а <code>#-1</code> — на предыдущую.<br />Теперь <code>comment</code>. Это — тот текст, который будет показан пользователю в виде всплывающей подсказки при наведении курсора мыши на ссылку. Его можно оставить пустым.<br /><code>area</code> — описание области, которая служит ссылкой. Тут разработчики дали нам довольно большую свободу — выделять можно не только прямоугольники, но также овалы и строки (строки, в принципе, можно было бы выделять прямоугольниками). Синтаксис всего этого добра вы можете найти в <code>man 1 djvused</code>. Я думаю, что читатель сам справится с выбором крайних координат для <code>rect</code>, <code>text</code> или <code>line</code> (в зависимости от того, чем вы решите выделять пункты оглавления).<br />Три точки в описании <code>maparea</code> означают, что вы можете задать дополнительные параметры, описывающие рамку вокруг ссылки. Тут у нас тоже довольно много вариантов — можно сделать инверсионную рамку (она будет чёрной, если фон белый, и наоборот; идеальна для цветного фона, когда цветная рамка может слиться с фоном), задать ей определённый цвет и толщину, а для некоторых типов выделения можно также задать тень.<br />Отдельно упомяну опцию <code>(border_avis)</code> — по умолчанию рамка показывается только при наведении на ссылку курсора мыши; данная же опция заставляет рамку отображаться всегда.<br />Теперь вы знаете всё необходимое. В качестве примера покажу секцию, которую я написал для оглавления одной из книг:<pre class="code"><code>(maparea "#12" "Chapter 1"<br />  (rect 220 759 93 23)<br />  (xor)<br />)</code></pre>Таким образом, имеем рамку с подсказкой «Chapter 1» и инверсионной рамкой, отображающейся только при наведении курсора мыши.<br />Наконец, встроим наши ссылки в файл:<div class="code"><code>$ djvused ВХОДНОЙ_ФАЙЛ.djvu -s -e "select 6; set-ant ФАЙЛ_СО_ССЫЛКАМИ"</code></div>Подразумевается, что оглавление находится на странице 6. Если это не так, поменяйте число после <code>select</code> на правильное.<br />Ещё раз обращаю ваше внимание на не–ASCII символы — они в обязательном порядке должны быть перекодированы в UTF–8 и представлены в восьмеричном виде! Почитайте <a href="#dealing_with_non-ascii_symbols">соответствующий раздел этого поста</a>, чтобы узнать больше.<br />Напоследок замечу, что ссылки — не единственное применение аннотаций. Вы также можете задавать дефолтный фоновой цвет страницы, степень её увеличения, режим дисплея (цветной, оттенки серого…), положение в окне ридера (по умолчанию — по центру, но можно сместить, скажем, в левый верхний угол), а также хранить информацию об авторе, названии, даже издания книги — о последнем и пойдёт речь в следующем разделе.<br /><br /><a name="metainformation"></a><h3>Метаинформация</h3>Djvu позволяет вам добавить в файл особый блок, содержащий данные об авторе, названии книги, годе издания и прочем. Это — метаинформация. В последующем она может быть извлечена и использована: например, если все ваши книги содержат такой блок, вы можете в автоматическом порядке переименовать все книги по единому шаблону, разложить их по директориям по издательствами или годам — да что угодно! При этом для того, чтобы добавить в свой djvu файл такие данные, вам нужно приложить совсем немного усилий.<br />Итак, хранение метаинформации в Djvu организовано с помощью того же механизма, что и ссылки, то есть с помощью аннотаций. Вот пример файла с метаинформацией:<pre class="code"><code>(metadata<br />  Author "Douglas Adams"<br />  Title  "The Hitchhiker's Guide to the Galaxy"<br />  Year   "1979"<br />)</code></pre>Обратите внимание на то, что внутри списка <code>metadata</code> нет вложенных списков — только пары ключ–значение. В мане сказано использовать списки, но мои эксперименты показали, что так делать нельзя — вложенные списки «удваиваются», т.е. конструкция вида <code>(key value)</code> превращается в <code>((key value))</code>, в результате чего информация не распознаётся ни читалками, ни <code>djvused</code>. Встроить метаинформацию в файл вам поможет следующая команда:<div class="code"><code>$ djvused ВЫХОДНОЙ_ФАЙЛ.djvu -s -e "set-mete ФАЙЛ_С_МЕТАИНФОРМАЦИЕЙ"</code></div>а извлечь — такая:<div class="code"><code>$ djvused ВХОДНОЙ_ФАЙЛ.djvu -e "select-shared-ant; print-meta"</code></div>Не забудьте, что не–ASCII символы должны быть представлены в виде UTF–8 строк, записанных в восьмеричном виде. Почитайте <a href="#dealing_with_non-ascii_symbols">соответствующий раздел этого поста</a> — там об этом рассказано подробнее.<br />Учтите, что порядок полей не соблюдается, т.е. в выводе второй команды поля могут идти не в том порядке, в каком вы внесли их в файл с метаинформацией.<br /><br /><a name="dealing_with_non-ascii_symbols"></a><h3>Работа с не–ASCII символами</h3>Согласно стандарту Djvu, все текстовые файлы, получающиеся при использовании <code>djvused</code> с командами <code>print-txt</code>, <code>print-meta</code> и прочими, должны быть представлены в кодировке ASCII. Для представления не–ASCII символов символ кодируется в UTF–8, а потом преобразуется в следующий вид: «\321\200\321\217\320\264\321\213,». Эта строка представляет собой набор восьмеричных значений, каждое из которых представляет один байт строки, закодированной в UTF–8.<br />Для того, чтобы вы понимали суть сказанного, приведу пример. Пусть имеем слово «привет». В этом слове шесть символов. В UTF–8 русские символы представляются <b>двумя</b> байтами, т.е. букве «п» соответствуют два байта — в восьмеричной форме они выглядят как 320 и 277. Добавляем бэкслеши в начале — voilà, мы получили именно то представление, которое используется в текстовых составляющих Djvu файлов.<br />Это было теория, теперь же перейдём к практике. А задача у нас такая — получив txt–файл с символами, закодированными вышеописанным способом, надо его преобразовать в человеческий UTF–8, который в дальнейшем можно без проблем править любимым редактором. И вторая часть задачи — по завершении правки выполнить обратное преобразование. Поможет нам в этом нелёгком деле утилита <code>uni2ascii</code> (спасибо, Camaleón!), которую мы с лёгкостью ставим из репозитория:<div class="code"><code>$ sudo aptitude install uni2ascii</code></div>Преобразовать файл из восьмеричного представления в Юникод позволяет такой однострочник:<div class="code"><code>$ ascii2uni -q -a K &lt; ВХОДНОЙ_ФАЙЛ.txt &gt; ВЫХОДНОЙ_ФАЙЛ.txt</code></div>а обратно — такой:<div class="code"><code>$ uni2ascii -q -a K &lt; ВХОДНОЙ_ФАЙЛ.txt &gt; ВЫХОДНОЙ_ФАЙЛ.txt</code>Впрочем, как я уже упоминал, этой рутины можно избежать, если при вызове <code>djvused</code> использовать опцию <code>-u</code>.<br /></div><a name="creating_djvu_file"></a><h3>Сборка итогового djvu–документа</h3>Завершающим этапом ваших трудов должен стать многостраничный djvu–документ, который легко, просто и быстро собирается из уже сжатых одностраничных djvu'шек такой командой:<div class="code"><code>$ djvm -c ВЫХОДНОЙ_ФАЙЛ.djvu *.djvu</code></div>Всё! Теперь можете наслаждаться свежесозданным документом.<br /><br />До новых встреч!<br /><br /><a name="updates"></a><b>UPD 21.06.2010:</b><ul><li>добавлены разделы о текстовом слое, ссылках и метаинформации (keks.sw, это благодаря твоему комментарию!)</li><li>расширен раздел об OCR, добавлено упоминание об опции <code>ocrodjvu</code> <code>--in-place</code>, а также программ <code>djvusmooth</code> и Cuneiform (спасибо, Lazy_Kent!)</li><li>исправлено неверное утверждение касательно способности PPM хранить цвет; соответствующий раздел обновлён (спасибо ещё раз, Lazy_Kent)</li><li>другие мелкие правки</li></ul><b>UPD 16.11.2010 (спасибо monday2000):</b><ul><li>добавлено упоминание о Scan Tailor</li><li>в качестве альтернативы <code>cjb2</code> упомянуты <code>minidjvu</code> и DjVu Solo 3.1, запускаемый под Wine</li><li>с недавних пор Tesseract начал понимать русский; упоминание об этом добавлено в статью</li><li>в <code>djvused</code> теперь можно отключать представление не–ASCII символов в виде их кодов — используя опцию <code>-u</code>, можно заставить <code>djvused</code> выводить символы в UTF–8</li></ul>

<h3 id='hakyll-convert-comments-title'>Comments</h3>
<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-14T11:05:04.602+03:00, Yurij wrote:</p>
<p class='hakyll-convert-comment-body'>
i̶m̶a̶g̶e̶m̶a̶g̶i̶c̶ imagemagick
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-14T12:06:37.073+03:00, Никита Мельниченко wrote:</p>
<p class='hakyll-convert-comment-body'>
А какой тип привязки (char, word, line, etc.) обычно вставляют автоматические распознавалки в текстовый слой? Насколько это удобно править?
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-14T13:43:58.213+03:00, Dr.AKULAvich wrote:</p>
<p class='hakyll-convert-comment-body'>
Спасибо за ликбез.<br />Мне нравится, как ты оформляешь посты. Сейчас вот глянул, как в html сделать &quot;отдельные части&quot; со ссылками на фрагменты поста.<br />Сделал для одной из заметок аналогичным образом, только не включал название частей в тег ссылки, чтобы исключить моргание.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-14T15:49:31.550+03:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
<b>Yurij</b>, спасибо за исправление — вечно забываю про «k» в конце, и команду, признаюсь, написал по памяти, а не скопировал из терминала.<br /><br /><b>2 Никита Мельниченко</b>:<br /><b>&gt; А какой тип привязки (char, word, line, etc.) обычно вставляют автоматические распознавалки в текстовый слой?</b><br />За все сразу не скажу, но могу рассказать про ocrodjvu (который, напоминаю, всего лишь фронтенд для tesseract). Он использует все доступные привязки в порядке спадания: сначала страница, в ней колонка, в ней регион, в ней абзацы, в них строки, в них слова или символы.<br /><br /><b>&gt; Насколько это удобно править?</b><br />Править, как мне кажется, неудобно. Я пробовал вычитать один абзац книги — задолбался переключаться между vim&#39;ом и djview (экран у нетбука маленький, два окна рядом не поставишь). Но это меньшая из бед — вот если распознавалка случайно слепила два слова в одно или вовсе проигнорировала целую строку, дело худо, потому что вам придётся самостоятельно выяснять координаты прямоугольника, в котором лежит строка/слово, и вбивать это дело в текстовик. Надеюсь, для этого есть какой-то GUI…<br /><br /><b>2 Dr.AKULAvich:</b><br /><b>&gt; только не включал название частей в тег ссылки</b><br />Гм, кстати да, надо починить — некрасиво же.<br /><br />Спасибо за комментарии!
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-15T14:29:32.273+03:00, keks.sw wrote:</p>
<p class='hakyll-convert-comment-body'>
Подозреваю, что имелось в виду &quot;C&#39;est la vie&quot;<br />Спасибо за рецепт.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-16T15:41:12.878+03:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
<b>2 keks.sw:</b><br />до твоего замечания искренне полагал, что «se la vi» по-французски так и пишется. Погуглил, прозрел. Спасибо!
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-19T16:13:01.565+03:00, idima89 wrote:</p>
<p class='hakyll-convert-comment-body'>
Есть ли способ под линаксом добавить в djvu ссылки в оглавление (чтоб можно было нажимать на них и сразу переходить на нужную страницу) и метаданные об авторе, название, годе издания?
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-20T08:47:16.651+03:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
<b>2 idima89</b>:<br />да, всё это можно сделать с помощью djvused и его команд print-ant, set-ant и print-meta, set-meta. С ними я, правда, ещё не разбирался, так что более подробно рассказать не могу. Увы, быстрая пробежка по инету не дала никаких результатов, так что придётся либо изучать самому, либо искать дольше и глубже.<br /><br />Удачи!
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-21T20:33:46.495+03:00, Lazy_Kent wrote:</p>
<p class='hakyll-convert-comment-body'>
1. c44 принимает PPM.<br />2. ocrodjvu поддерживает Cuneiform, у которого с русским всё в порядке.<br />3. У ocrodjvu есть опция --in-place.<br />4. Для редактирования текста и создания оглавления есть графическая программа djvusmooth (от автора ocrodjvu).
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-22T00:11:56.295+03:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
1. <b>&gt; c44 принимает PPM.</b><br />Мне казалось, что PPM не умеет хранить цвет (по карйней мере, я с помощью утилит из netpbm не смог получить цветной ppm — надо будет разобраться, почему). Сейчас почитал немного интернет, прозрел, поправил соответствующий раздел.<br /><br />2. <b>&gt; ocrodjvu поддерживает Cuneiform, у которого с русским всё в порядке.</b><br />Не знал. Правда, Cuneiform — это non-free, к тому же есть только в сиде…<br />Тем не менее, упоминание добавил.<br /><br />3. <b>&gt; У ocrodjvu есть опция --in-place.</b><br />В статье упоминалось, что ocrodjvu может переписывать документ. На всякий случай добавил готовую команду-пример с использованием --in-place<br /><br />4. <b>&gt; Для редактирования текста и создания оглавления есть графическая программа djvusmooth (от автора ocrodjvu).</b><br />О, тот самый GUI, на существование которого я так надеялся (см. мой первый комментарий)! Спасибо огромное, с удовольствием добавил в пост и поюзал сам.<br /><br />Спасибо ещё раз за ценные замечания, Lazy_Kent!
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-22T07:05:04.270+03:00, morbo wrote:</p>
<p class='hakyll-convert-comment-body'>
Такие вот команды<br /><br />cat ВХОДНОЙ_ФАЙЛ.txt | uni2ascii -q -a K &gt; ВЫХОДНОЙ_ФАЙЛ.txt<br /><br />можно записать проще:<br /><br />uni2ascii -q -a K &lt; ВХОДНОЙ_ФАЙЛ.txt &gt; ВЫХОДНОЙ_ФАЙЛ.txt
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-22T07:11:02.311+03:00, morbo wrote:</p>
<p class='hakyll-convert-comment-body'>
Глядя на скобки в текстовых файлах, вкрадывается смутное подозрение: авторы утилит - лисперы? (Кстати, вот вам и пример встроенного проблемно-ориентированного языка, о котором часто говорил Луговский.)
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-22T09:04:50.540+03:00, Анонимный wrote:</p>
<p class='hakyll-convert-comment-body'>
Для обработки сканов перед кодированием есть прекрасная кроссплатформенная программы Scan Tailor - http://scantailor.sf.net/<br />Русскоязычный форум для её - http://forum.ru-board.com/topic.cgi?forum=5&amp;topic=32945&amp;start=0
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-22T15:10:39.898+03:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
<b>2 morbo:</b><br /><b>&gt; можно записать проще</b><br />Да, не подумал об этом. Спасибо!<br /><br /><b>&gt; авторы утилит - лисперы?</b><br />Может быть, может быть…<br /><br /><br /><b>2 Анонимный</b><br /><b>&gt; Для обработки сканов перед кодированием есть прекрасная кроссплатформенная программы Scan Tailor</b><br />Я же в самом начале статьи сказал, что вопрос сканирования и обработки сканов рассматриваться не будет — я описываю конкретно процесс создания djvu.<br /><br />За ссылки спасибо — может, почитаю на досуге — но добавлять это в пост не собираюсь.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-23T13:17:09.032+03:00, Lazy_Kent wrote:</p>
<p class='hakyll-convert-comment-body'>
Джентльмены, я сейчас делаю перевод djvusmooth на русский язык. Почти всё готово. Испытываю трудности со словами &quot;Flatten&quot; и &quot;Pushpin&quot;.<br />Кто попользовался программой, подскажите, как лучше перевести.<br />И ещё: раздел &quot;Outline&quot; назвать &quot;оглавление&quot;?
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-26T09:03:59.891+03:00, galaxycitizen wrote:</p>
<p class='hakyll-convert-comment-body'>
при подготовке сканов хорошо себя зарекомендовал Scan Tailor, правда я делаю книги в оттенках серого или черно белыми, как он с цветом обращается не знаю
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-26T10:49:32.394+03:00, galaxycitizen wrote:</p>
<p class='hakyll-convert-comment-body'>
Улучшение качества DJVU книг<br />http://surrender-zen-way.blogspot.com/2010/02/djvu.html - pвконце есть скрипт сборки DJVU<br /><br /><br />Обработка сфотографированых/отсканированных страниц документов с помощью imagemagick<br />http://surrender-zen-way.blogspot.com/2009/07/imagemagic.html
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-06-27T23:31:14.371+03:00, Анонимный wrote:</p>
<p class='hakyll-convert-comment-body'>
Не подскажут ли благородные Доны, почему созданные при помощи djvulibre мною djvu отлично смотрятся на линаксе и в (простите) уиндусе под WinDjview, но не в популярном DjVuReader&#39;е. В нём наблюдается проблемка --- страницы перевёрнуты и отражены. В принципе, хрен бы с ним --- DjVuReader безнадёжно устарел, давно не поддерживается, а автор потерял исходники. Но интересует, почему только эти djvu? С остальными всё в порядке. Версия djvulibre --- 3.5.22-2.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-09-11T12:12:39.111+03:00, Arkady wrote:</p>
<p class='hakyll-convert-comment-body'>
Если надо быстро, много и грубо - вот этот скрипт. (У меня было порядка 300 статей, которые надо было превратить в djvu)<br /><br />#Автоматизация создания djvu-файлов.<br />#Предполагается следующая структура каталогов<br />#Scans - корневой каталог. Scans/issuenumber - папка, в которой лежит скан статьи с номером issuenumber(можно любое название, но без пробелов)<br />#Scans/issuenumber/out - каталог, в котором лежат обработанные ScanTailor или ScanKromsator сканы в формате .tif с названиями *.tif<br />#Файлы сохраняются под именами issuenumber.djvu в Scans<br /><br />!#/bin/sh<br />for dir in /home/arkady/Scans/* ; do <br />cd $dir/out ; <br />for file in *.tif ; do anytopnm $file | ppmtopgm &gt; ${file%tif}pgm; done ;<br />for file in *.pgm ; do cpaldjvu -dpi 300 -colors 5 $file ${file%pgm}djvu; done ;<br />d=${PWD%/out} ;<br />d=${d#/home/arkady/Scans/} ;<br />djvm -c /home/arkady/Scans/$d.djvu *.djvu ;<br />echo created $d.djvu ;<br />rm *.pgm ;<br />rm *.djvu ;<br />done
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-11-16T19:56:53.534+02:00, monday2000 wrote:</p>
<p class='hakyll-convert-comment-body'>
Спасибо за интересную статью!<br /><br />Некоторые замечания:<br /><br />- Процесс подготовки сканов под кодирование в DjVu слишком тесно связан с непосредственно созданием DjVu - так что его тоже имеет смысл освещать (Scan Tailor).<br /><br />- Вместо cjb2 для кодирования в DjVu чёрно-белых сканов следует использовать хотя бы minidjvu. Но лучше всего DjVu Solo 3.1 в Wine запустить. Это уже проверялось на работоспособность под Linux.<br /><br />- В статье не освещён Метод разделённых сканов при создании DjVu. Под Linux для этого существует готовый инструмент: http://www.djvu-scan.ru/forum/index.php?topic=96.0 .<br /><br />- tesseract уже распознаёт русский язык.<br /><br />- djvused уже умеет выдавать полностью человеко-читаемые файлы. Для этого там на днях введена опция -u. То есть вместо строки «\320\222\320\262\320\265\320\264\320\265\320\275\320\270\320\265» будут человеко-читаемые буквы.<br /><br />- кому не нравится djvused, могут юзать бесплатные DjVu XML утилиты - эффект то же самый, но только через XML-файлы (ИМХО так удобней).<br /><br />- Существует т.н. &quot;конвейер&quot; под Linux - см. http://www.djvu-soft.narod.ru/soft/all2djvu.htm .<br /><br />- Есть ещё и ABBYY FineReader под Linux. См. http://ocr4linux.com/ . Можно им создавать OCR-слой в DjVu - находясь под Линуксом.<br /><br />- Теоретически в природе существует коммерческий DjVu SDK в Линукс-версии - на Caminova.net . Но никто ещё никогда его не видел. Пока что в ходу лишь виндовые DjVu SDK.<br /><br />- Главный вывод в том, что свободно-бесплатными инструментами хороший DjVu под Линукс можно сделать только посредством DjVu Solo 3.1 под Wine. cjb2 - это полный отстой. minidjvu - тоже не фонтан (хотя и много лучше).<br /><br />- Если будет желание, заходите на мой форум http://www.djvu-scan.ru/forum/index.php - пообщаемся поконкретнее. Тема DjVu под Linux - это интересно.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-11-16T21:10:56.890+02:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
<b>monday2000</b>, благодарю за содержательный комментарий! Сейчас поправлю соответствующие части статьи.<br /><br />Про Scan Tailor я рассказывать не хотел потому, что в моём случае нужно было из уже готовых постраничных сканов (обработанных) сделать книжку, и пост как раз на этом и сосредоточен. Тем не менее, учитывая количество комментариев с упоминаниями Scan Tailor, я добавлю отсылку к нему в начало статьи.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-11-16T23:22:42.542+02:00, ashipunov wrote:</p>
<p class='hakyll-convert-comment-body'>
monday2000 уже упомянул о моем img2djvu ( https://github.com/ashipunov/img2djvu ), хотелось бы добавить, что главное, на мой взгляд, его достоинство -- это возможность комбинировать разные методы кодирования (два вида цветного, малоцветный и два вида черно-белого) в зависимости от типа изображения и указанных опций.<br />===<br />С уважением,<br />А. Шипунов
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-11-17T17:01:32.594+02:00, monday2000 wrote:</p>
<p class='hakyll-convert-comment-body'>
Является ли требование использования свободно-бесплатных DjVu-программ под Linux обязательным?<br /><br />Дело в том, что, как ни крути, а самое лучшее - это частично использовать пиратские версии коммерческих DjVu-программ. Хотя бы для создания чёрно-белого DjVu.<br /><br />Но ещё в большей мере это относится к OCR-нию. К сожалению, никакой CuneiForm или Tesseract не сравнится с ABBYY FineReader (который сейчас есть уже прямо под Линукс).<br /><br />Поэтому, с точки зрения реальной жизни, целесообразно несколько смириться с частичным использованием нелегальных Линукс - DjVu-программ. <br /><br />Хотя, конечно, лично мне очень хотелось бы обойтись только одними легальными. Но, если признаться честно - использование исключительно лишь свободно-бесплатного DjVu-софта - это баловство, несерьёзно это. Точнее, для части DjVu-задач использование свободно-бесплатного DjVu-софта ничем не хуже использования коммерческого, но есть, увы, такие DjVu-задачи, где по-хорошему без вареза не обойтись - иначе качество будет не то.<br /><br />DjVu Solo 3.1 - это, пожалуй, единственное исключение. Будучи легально свободно-бесплатной программой, она, тем не менее, даёт качество почти такое же, как и у коммерческих платных DjVu-кодировщиков.<br /><br />Использовать cjb2 категорически несерьёзно. Да и minidjvu то же самое - если честно признаться. Самое правильное - отговаривать всех в статье от использования cjb2. А в качестве основного средства преподносить DjVu Solo 3.1 под Wine.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-11-18T05:49:49.542+02:00, ashipunov wrote:</p>
<p class='hakyll-convert-comment-body'>
Мне кажется, что не стОит рубить сплеча. Вот Вам пример: три файла из одних и тех же исходников -- http://rghost.ru/3292522 . Один сделан cjb2, другой сделан minidjvu, третий сделан documenttodjvu. В двух текстовый слой сделан cuneiform, в одном -- FR8. Угадайте, где какой ;-)
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-11-18T12:52:20.596+02:00, monday2000 wrote:</p>
<p class='hakyll-convert-comment-body'>
&gt; Мне кажется, что не стОит рубить сплеча.<br />Я думаю, Вы и сами понимаете, что один специально подобранный пример - это не показатель.<br /><br />cjb2 ИМХО вообще нецелесообразно сравнивать с аналогами - поскольку он в принципе не использует словари разделённых символов при созданиии DjVu - а значит, заведомо хуже всех.<br /><br />CuneiForm с Файнридером даже как-то грустно сравнивать. Слишком уж велика разница в мощности. Хотя, ИМХО у CuneiForm есть перспективы улучшения - я лишь на это рассчитываю (говоря о CuneiForm).
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2010-11-19T09:13:37.800+02:00, ashipunov wrote:</p>
<p class='hakyll-convert-comment-body'>
Я не подбирал этот пример.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2012-09-19T23:00:18.496+03:00, Анонимный wrote:</p>
<p class='hakyll-convert-comment-body'>
если этот форум ещё жив - подскажите, пожалуйста, - как можно автоматизировать работу утилиты cpaldjvu. Мне необходимо следующее: у меня есть уже готовые к форматированию файлы PGM-формата. Мне нужно их &quot;пакетом&quot; перегнать в DJVU-формат. Команда #cpaldjvu -dpi 600 -colors 16 001_1L.pgm 001_1L.djvu работает для ОДНОГО файла. Пробовал написать следующее: #for file in *pgm; do cpaldjvu -dpi 600 -colors 16 $file &gt; ${file%pgm}djvu; done - не работает. Прошу скрипты ПОЛНОЙ обработки не предлагать - мне нужно автоматизировать только один этап - перегонку из PGM в DJVU.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2012-09-19T23:41:28.659+03:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
Это не форум, это блог :)<br /><br />Вывод cpaldjvu никуда не нужно перенаправлять — программа принимает имя выходного файла последним параметром. То есть твой цикл должен выглядеть так:<br /><br />for file in *.pgm; do cpaldjvu -dpi 600 -colors 16 $file ${file%pgm}djvu ; done
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2013-12-16T01:18:04.501+02:00, Никита Егоров wrote:</p>
<p class='hakyll-convert-comment-body'>
А не подскажете, почему на конвертации в серый цвет вы не использовали все тот же convert, а связку из нескольких программ?
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2014-01-22T20:27:40.639+02:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
Blogger на меня обиделся и не пущал комментировать из-под родного гугловского аккаунта и Chromium. А сейчас, из Firefox, пустило. Страннота!<br /><br />В общем, Никит, на выбор утилит для конвертирования повлиял мануал, на который я сослался в начале поста. Можно использовать и convert, конечно, но я не пробовал.
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2015-06-03T11:05:10.756+03:00, Murfen wrote:</p>
<p class='hakyll-convert-comment-body'>
Спасибо большое за описание!<br />1. Для ч/б страниц, состоящих только из текста, у меня гораздо лучше результат получился командой: <br />convert -threshold 70% ИСХОДНЫЙ_ФАЙЛ ВЫХОДНОЙ_ФАЙЛ.pbm<br /><br />2. Есть ряд страниц с текстом и иллюстрациями. Пытаюсь их кодировать программой  cpaldjvu с 5 цветами - получается очень бледно, с 8 цветами - размер файла в 1,5 раза больше, чем исходный jpeg. Пытаюсь их же кодировать как цветные - комадной c44 - размер получается в самый раз. В чем магия?
</p>
</div>

<div class='hakyll-convert-comment'>
<p class='hakyll-convert-comment-date'>On 2015-06-12T14:55:18.717+03:00, Minoru wrote:</p>
<p class='hakyll-convert-comment-body'>
<b>Murfen</b>, спасибо за комментарий! И прости, что задержал с ответом.<br /><br />Что касается convert -threshold, тот значение тут зависит от сканов. Как уже сказано в статье, экспериментировать с величиной никто не запрещает.<br /><br />По второму пункту — две цитаты из <a href="http://djvu.sourceforge.net/doc/index.html" rel="nofollow">оглавления документации DjVuLibre</a>:<br /><br /><i>&gt; cpaldjvu — A DjVuDocument command line encoder for images with few colors. This encoder is well suited to compressing images with a small number of distinct colors (e.g. screen-shots). The dominant color is encoded by the background layer. The other colors are encoded by the foreground layer. </i><br /><br /><i>&gt; c44 — A DjVuPhoto command line encoder. This state-of-the-art wavelet compressor produces DjVuPhoto images from PPM or JPEG images. </i><br /><br />Если совсем вкратце, то ответом на твой вопрос будет «просто алгоритмы сильно разные». Если подробней, то cpaldjvu семь из восьми цветов загонит в передний слой, который в высоком разрешении — отсюда и резкий рост размера файла. О вейвлетах я подробностей не знаю, но, предположительно, они правильно раскладывают цвета по слоям и, как следствие, дают подходящий результат.<br /><br />Из твоего опыта можно сделать вывод, что если нет времени возиться с подбором количества цветов, можно просто скормить все сканы c44.
</p>
</div>



